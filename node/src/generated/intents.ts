// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.28.3
// source: intents.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FallbackMessage } from "./projects.js";

export const protobufPackage = "aristech.nlp";

/**
 * OutputMessage
 * -------------
 * Describes a single response of an intent.
 */
export interface OutputMessage {
  /** Channel through which the message is delivered. */
  channel: OutputMessage_Channel;
  /**
   * Flexible key/value pairs for message data.
   * Example: "text": "Hello, how can I help?"
   *          "redirect": "intent_123"
   *          "tts_speed": "slow"
   */
  data: { [key: string]: string };
}

export enum OutputMessage_Channel {
  /** CHAT - Text chat */
  CHAT = 0,
  /** VOICE - Voice channel */
  VOICE = 1,
  /** EMAIL - Email */
  EMAIL = 2,
  UNRECOGNIZED = -1,
}

export function outputMessage_ChannelFromJSON(object: any): OutputMessage_Channel {
  switch (object) {
    case 0:
    case "CHAT":
      return OutputMessage_Channel.CHAT;
    case 1:
    case "VOICE":
      return OutputMessage_Channel.VOICE;
    case 2:
    case "EMAIL":
      return OutputMessage_Channel.EMAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutputMessage_Channel.UNRECOGNIZED;
  }
}

export function outputMessage_ChannelToJSON(object: OutputMessage_Channel): string {
  switch (object) {
    case OutputMessage_Channel.CHAT:
      return "CHAT";
    case OutputMessage_Channel.VOICE:
      return "VOICE";
    case OutputMessage_Channel.EMAIL:
      return "EMAIL";
    case OutputMessage_Channel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OutputMessage_DataEntry {
  key: string;
  value: string;
}

/**
 * Intent
 * ------
 * Represents an intent within a project.
 */
export interface Intent {
  /** Unique ID of the intent. */
  id: string;
  /** Project ID to which this intent belongs. */
  projectId: string;
  /** Default locale for input and output. */
  locale: string;
  /** Topic assignment of the intent. */
  topic: string;
  /** List of inputs (IntentInput) assigned to this intent. */
  inputs: IntentInput[];
  /**
   * Old, channel-separated outputs (still present).
   *
   * @deprecated
   */
  outputChat: string[];
  /** @deprecated */
  outputVoice: string[];
  /** @deprecated */
  outputEmail: string[];
  /** New, extensible outputs. */
  outputs: OutputMessage[];
  /** Relationships to other intents (parents, children, peers). */
  relatedTo: Relation[];
  /** Indicates whether the intent is published (not a draft). */
  published: boolean;
  /** If true, the output of this intent is excluded from search queries. */
  excludeOutputFromSearch: boolean;
  /** List of keywords for targeted search. */
  keywords: Keyword[];
  /** ID of the creator of this intent. */
  creatorId: string;
}

/**
 * IntentInput
 * -----------
 * Defines an input for an intent.
 * Each input can be identified by UUID; if it does not exist, a new input is created.
 */
export interface IntentInput {
  /** UUID for identification. */
  uuid: string;
  /** The actual input text. */
  input: string;
}

/** Relation */
export interface Relation {
  /** Parents are intents that are directly related to this intent. */
  parents: string[];
  /** Children are intents that are directly related to this intent. */
  children: string[];
  /** Peers are intents that are at the same level in the hierarchy. */
  peers: string[];
}

/**
 * Keyword
 * -------
 * Represents a keyword for identification or prioritization of an intent.
 */
export interface Keyword {
  /** The keyword. */
  keyword: string;
  /** Priority (e.g. for ranking). */
  priority: number;
}

/**
 * UpdateContentRequest
 * --------------------
 * Used to add or update intents.
 */
export interface UpdateContentRequest {
  /** Intents to add or update. */
  intents: Intent[];
}

/**
 * UpdateContentResponse
 * ---------------------
 * Contains the status of the update operation.
 */
export interface UpdateContentResponse {
  /** IDs of added or updated intents. */
  intentIds: string[];
}

/**
 * RemoveContentRequest
 * --------------------
 * Used to remove intents.
 */
export interface RemoveContentRequest {
  /** IDs of intents to delete. */
  id: string[];
  /** Project from which to delete. */
  projectId: string;
}

/** Confirms removal of intents. */
export interface RemoveContentResponse {
}

/**
 * GetContentRequest
 * -----------------
 * Retrieves content (intents) and performs similarity searches.
 */
export interface GetContentRequest {
  prompt: string;
  projectId: string;
  numResults: number;
  threshold: number;
  filters: ContentFilter[];
  chatId: string;
}

/**
 * GetContentResponse
 * ------------------
 * Response to a content query.
 */
export interface GetContentResponse {
  items: ContentResponseItem[];
  chatId: string;
}

/**
 * ContentFilter
 * -------------
 * Defines filter criteria for content queries.
 */
export interface ContentFilter {
  field: string;
  value: string;
  operator: string;
  label: string[];
}

/**
 * ContentResponseItem
 * -------------------
 * A single search result.
 */
export interface ContentResponseItem {
  /** ID of the matching IntentInput element. */
  id: string;
  /** Similarity/relevance score. */
  score: number;
  /** Full intent. */
  intent:
    | Intent
    | undefined;
  /** A single fallback message as a string */
  fallbackMessage: string;
  fallbackMessages: FallbackMessage[];
}

/**
 * GetIntentsRequest
 * -----------------
 * Requests all intents of a specific project.
 */
export interface GetIntentsRequest {
  projectId: string;
}

/**
 * GetScoreLimitsRequest
 * ---------------------
 * Determines score limits for a project.
 */
export interface GetScoreLimitsRequest {
  projectId: string;
  testSentencesUpperLimit: string[];
  testSentencesLowerLimit: string[];
}

/**
 * GetScoreLimitsResponse
 * ----------------------
 * Returns the determined score limits for a project.
 */
export interface GetScoreLimitsResponse {
  minThreshold: number;
  maxThreshold: number;
}

function createBaseOutputMessage(): OutputMessage {
  return { channel: 0, data: {} };
}

export const OutputMessage: MessageFns<OutputMessage> = {
  encode(message: OutputMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      OutputMessage_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = OutputMessage_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputMessage {
    return {
      channel: isSet(object.channel) ? outputMessage_ChannelFromJSON(object.channel) : 0,
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: OutputMessage): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = outputMessage_ChannelToJSON(message.channel);
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputMessage>, I>>(base?: I): OutputMessage {
    return OutputMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputMessage>, I>>(object: I): OutputMessage {
    const message = createBaseOutputMessage();
    message.channel = object.channel ?? 0;
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseOutputMessage_DataEntry(): OutputMessage_DataEntry {
  return { key: "", value: "" };
}

export const OutputMessage_DataEntry: MessageFns<OutputMessage_DataEntry> = {
  encode(message: OutputMessage_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputMessage_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputMessage_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputMessage_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OutputMessage_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputMessage_DataEntry>, I>>(base?: I): OutputMessage_DataEntry {
    return OutputMessage_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputMessage_DataEntry>, I>>(object: I): OutputMessage_DataEntry {
    const message = createBaseOutputMessage_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIntent(): Intent {
  return {
    id: "",
    projectId: "",
    locale: "",
    topic: "",
    inputs: [],
    outputChat: [],
    outputVoice: [],
    outputEmail: [],
    outputs: [],
    relatedTo: [],
    published: false,
    excludeOutputFromSearch: false,
    keywords: [],
    creatorId: "",
  };
}

export const Intent: MessageFns<Intent> = {
  encode(message: Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.topic !== "") {
      writer.uint32(34).string(message.topic);
    }
    for (const v of message.inputs) {
      IntentInput.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.outputChat) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.outputVoice) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.outputEmail) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.outputs) {
      OutputMessage.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.relatedTo) {
      Relation.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.published !== false) {
      writer.uint32(80).bool(message.published);
    }
    if (message.excludeOutputFromSearch !== false) {
      writer.uint32(96).bool(message.excludeOutputFromSearch);
    }
    for (const v of message.keywords) {
      Keyword.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.creatorId !== "") {
      writer.uint32(114).string(message.creatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputs.push(IntentInput.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputChat.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputVoice.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputEmail.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.outputs.push(OutputMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.relatedTo.push(Relation.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.published = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.excludeOutputFromSearch = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.keywords.push(Keyword.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => IntentInput.fromJSON(e)) : [],
      outputChat: globalThis.Array.isArray(object?.outputChat)
        ? object.outputChat.map((e: any) => globalThis.String(e))
        : [],
      outputVoice: globalThis.Array.isArray(object?.outputVoice)
        ? object.outputVoice.map((e: any) => globalThis.String(e))
        : [],
      outputEmail: globalThis.Array.isArray(object?.outputEmail)
        ? object.outputEmail.map((e: any) => globalThis.String(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => OutputMessage.fromJSON(e))
        : [],
      relatedTo: globalThis.Array.isArray(object?.relatedTo)
        ? object.relatedTo.map((e: any) => Relation.fromJSON(e))
        : [],
      published: isSet(object.published) ? globalThis.Boolean(object.published) : false,
      excludeOutputFromSearch: isSet(object.excludeOutputFromSearch)
        ? globalThis.Boolean(object.excludeOutputFromSearch)
        : false,
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => Keyword.fromJSON(e)) : [],
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
    };
  },

  toJSON(message: Intent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => IntentInput.toJSON(e));
    }
    if (message.outputChat?.length) {
      obj.outputChat = message.outputChat;
    }
    if (message.outputVoice?.length) {
      obj.outputVoice = message.outputVoice;
    }
    if (message.outputEmail?.length) {
      obj.outputEmail = message.outputEmail;
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => OutputMessage.toJSON(e));
    }
    if (message.relatedTo?.length) {
      obj.relatedTo = message.relatedTo.map((e) => Relation.toJSON(e));
    }
    if (message.published !== false) {
      obj.published = message.published;
    }
    if (message.excludeOutputFromSearch !== false) {
      obj.excludeOutputFromSearch = message.excludeOutputFromSearch;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords.map((e) => Keyword.toJSON(e));
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Intent>, I>>(base?: I): Intent {
    return Intent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Intent>, I>>(object: I): Intent {
    const message = createBaseIntent();
    message.id = object.id ?? "";
    message.projectId = object.projectId ?? "";
    message.locale = object.locale ?? "";
    message.topic = object.topic ?? "";
    message.inputs = object.inputs?.map((e) => IntentInput.fromPartial(e)) || [];
    message.outputChat = object.outputChat?.map((e) => e) || [];
    message.outputVoice = object.outputVoice?.map((e) => e) || [];
    message.outputEmail = object.outputEmail?.map((e) => e) || [];
    message.outputs = object.outputs?.map((e) => OutputMessage.fromPartial(e)) || [];
    message.relatedTo = object.relatedTo?.map((e) => Relation.fromPartial(e)) || [];
    message.published = object.published ?? false;
    message.excludeOutputFromSearch = object.excludeOutputFromSearch ?? false;
    message.keywords = object.keywords?.map((e) => Keyword.fromPartial(e)) || [];
    message.creatorId = object.creatorId ?? "";
    return message;
  },
};

function createBaseIntentInput(): IntentInput {
  return { uuid: "", input: "" };
}

export const IntentInput: MessageFns<IntentInput> = {
  encode(message: IntentInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentInput {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
    };
  },

  toJSON(message: IntentInput): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntentInput>, I>>(base?: I): IntentInput {
    return IntentInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntentInput>, I>>(object: I): IntentInput {
    const message = createBaseIntentInput();
    message.uuid = object.uuid ?? "";
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseRelation(): Relation {
  return { parents: [], children: [], peers: [] };
}

export const Relation: MessageFns<Relation> = {
  encode(message: Relation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parents) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.children) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.peers) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Relation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parents.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.peers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Relation {
    return {
      parents: globalThis.Array.isArray(object?.parents) ? object.parents.map((e: any) => globalThis.String(e)) : [],
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => globalThis.String(e)) : [],
      peers: globalThis.Array.isArray(object?.peers) ? object.peers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Relation): unknown {
    const obj: any = {};
    if (message.parents?.length) {
      obj.parents = message.parents;
    }
    if (message.children?.length) {
      obj.children = message.children;
    }
    if (message.peers?.length) {
      obj.peers = message.peers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Relation>, I>>(base?: I): Relation {
    return Relation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Relation>, I>>(object: I): Relation {
    const message = createBaseRelation();
    message.parents = object.parents?.map((e) => e) || [];
    message.children = object.children?.map((e) => e) || [];
    message.peers = object.peers?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeyword(): Keyword {
  return { keyword: "", priority: 0 };
}

export const Keyword: MessageFns<Keyword> = {
  encode(message: Keyword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyword !== "") {
      writer.uint32(10).string(message.keyword);
    }
    if (message.priority !== 0) {
      writer.uint32(16).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Keyword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Keyword {
    return {
      keyword: isSet(object.keyword) ? globalThis.String(object.keyword) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: Keyword): unknown {
    const obj: any = {};
    if (message.keyword !== "") {
      obj.keyword = message.keyword;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Keyword>, I>>(base?: I): Keyword {
    return Keyword.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Keyword>, I>>(object: I): Keyword {
    const message = createBaseKeyword();
    message.keyword = object.keyword ?? "";
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseUpdateContentRequest(): UpdateContentRequest {
  return { intents: [] };
}

export const UpdateContentRequest: MessageFns<UpdateContentRequest> = {
  encode(message: UpdateContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intents) {
      Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intents.push(Intent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContentRequest {
    return {
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => Intent.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateContentRequest): unknown {
    const obj: any = {};
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => Intent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(base?: I): UpdateContentRequest {
    return UpdateContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(object: I): UpdateContentRequest {
    const message = createBaseUpdateContentRequest();
    message.intents = object.intents?.map((e) => Intent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateContentResponse(): UpdateContentResponse {
  return { intentIds: [] };
}

export const UpdateContentResponse: MessageFns<UpdateContentResponse> = {
  encode(message: UpdateContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intentIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intentIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContentResponse {
    return {
      intentIds: globalThis.Array.isArray(object?.intentIds)
        ? object.intentIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateContentResponse): unknown {
    const obj: any = {};
    if (message.intentIds?.length) {
      obj.intentIds = message.intentIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContentResponse>, I>>(base?: I): UpdateContentResponse {
    return UpdateContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContentResponse>, I>>(object: I): UpdateContentResponse {
    const message = createBaseUpdateContentResponse();
    message.intentIds = object.intentIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveContentRequest(): RemoveContentRequest {
  return { id: [], projectId: "" };
}

export const RemoveContentRequest: MessageFns<RemoveContentRequest> = {
  encode(message: RemoveContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.id) {
      writer.uint32(10).string(v!);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveContentRequest {
    return {
      id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [],
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: RemoveContentRequest): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveContentRequest>, I>>(base?: I): RemoveContentRequest {
    return RemoveContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveContentRequest>, I>>(object: I): RemoveContentRequest {
    const message = createBaseRemoveContentRequest();
    message.id = object.id?.map((e) => e) || [];
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseRemoveContentResponse(): RemoveContentResponse {
  return {};
}

export const RemoveContentResponse: MessageFns<RemoveContentResponse> = {
  encode(_: RemoveContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveContentResponse {
    return {};
  },

  toJSON(_: RemoveContentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveContentResponse>, I>>(base?: I): RemoveContentResponse {
    return RemoveContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveContentResponse>, I>>(_: I): RemoveContentResponse {
    const message = createBaseRemoveContentResponse();
    return message;
  },
};

function createBaseGetContentRequest(): GetContentRequest {
  return { prompt: "", projectId: "", numResults: 0, threshold: 0, filters: [], chatId: "" };
}

export const GetContentRequest: MessageFns<GetContentRequest> = {
  encode(message: GetContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.numResults !== 0) {
      writer.uint32(24).int32(message.numResults);
    }
    if (message.threshold !== 0) {
      writer.uint32(37).float(message.threshold);
    }
    for (const v of message.filters) {
      ContentFilter.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.chatId !== "") {
      writer.uint32(58).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numResults = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.threshold = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(ContentFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContentRequest {
    return {
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      numResults: isSet(object.numResults) ? globalThis.Number(object.numResults) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => ContentFilter.fromJSON(e))
        : [],
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: GetContentRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.numResults !== 0) {
      obj.numResults = Math.round(message.numResults);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => ContentFilter.toJSON(e));
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContentRequest>, I>>(base?: I): GetContentRequest {
    return GetContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContentRequest>, I>>(object: I): GetContentRequest {
    const message = createBaseGetContentRequest();
    message.prompt = object.prompt ?? "";
    message.projectId = object.projectId ?? "";
    message.numResults = object.numResults ?? 0;
    message.threshold = object.threshold ?? 0;
    message.filters = object.filters?.map((e) => ContentFilter.fromPartial(e)) || [];
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseGetContentResponse(): GetContentResponse {
  return { items: [], chatId: "" };
}

export const GetContentResponse: MessageFns<GetContentResponse> = {
  encode(message: GetContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ContentResponseItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ContentResponseItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContentResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ContentResponseItem.fromJSON(e))
        : [],
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: GetContentResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ContentResponseItem.toJSON(e));
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContentResponse>, I>>(base?: I): GetContentResponse {
    return GetContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContentResponse>, I>>(object: I): GetContentResponse {
    const message = createBaseGetContentResponse();
    message.items = object.items?.map((e) => ContentResponseItem.fromPartial(e)) || [];
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseContentFilter(): ContentFilter {
  return { field: "", value: "", operator: "", label: [] };
}

export const ContentFilter: MessageFns<ContentFilter> = {
  encode(message: ContentFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    for (const v of message.label) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      label: globalThis.Array.isArray(object?.label) ? object.label.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ContentFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.label?.length) {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentFilter>, I>>(base?: I): ContentFilter {
    return ContentFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentFilter>, I>>(object: I): ContentFilter {
    const message = createBaseContentFilter();
    message.field = object.field ?? "";
    message.value = object.value ?? "";
    message.operator = object.operator ?? "";
    message.label = object.label?.map((e) => e) || [];
    return message;
  },
};

function createBaseContentResponseItem(): ContentResponseItem {
  return { id: "", score: 0, intent: undefined, fallbackMessage: "", fallbackMessages: [] };
}

export const ContentResponseItem: MessageFns<ContentResponseItem> = {
  encode(message: ContentResponseItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.intent !== undefined) {
      Intent.encode(message.intent, writer.uint32(26).fork()).join();
    }
    if (message.fallbackMessage !== "") {
      writer.uint32(34).string(message.fallbackMessage);
    }
    for (const v of message.fallbackMessages) {
      FallbackMessage.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentResponseItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentResponseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intent = Intent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fallbackMessage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fallbackMessages.push(FallbackMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentResponseItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      intent: isSet(object.intent) ? Intent.fromJSON(object.intent) : undefined,
      fallbackMessage: isSet(object.fallbackMessage) ? globalThis.String(object.fallbackMessage) : "",
      fallbackMessages: globalThis.Array.isArray(object?.fallbackMessages)
        ? object.fallbackMessages.map((e: any) => FallbackMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContentResponseItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.intent !== undefined) {
      obj.intent = Intent.toJSON(message.intent);
    }
    if (message.fallbackMessage !== "") {
      obj.fallbackMessage = message.fallbackMessage;
    }
    if (message.fallbackMessages?.length) {
      obj.fallbackMessages = message.fallbackMessages.map((e) => FallbackMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentResponseItem>, I>>(base?: I): ContentResponseItem {
    return ContentResponseItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentResponseItem>, I>>(object: I): ContentResponseItem {
    const message = createBaseContentResponseItem();
    message.id = object.id ?? "";
    message.score = object.score ?? 0;
    message.intent = (object.intent !== undefined && object.intent !== null)
      ? Intent.fromPartial(object.intent)
      : undefined;
    message.fallbackMessage = object.fallbackMessage ?? "";
    message.fallbackMessages = object.fallbackMessages?.map((e) => FallbackMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetIntentsRequest(): GetIntentsRequest {
  return { projectId: "" };
}

export const GetIntentsRequest: MessageFns<GetIntentsRequest> = {
  encode(message: GetIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIntentsRequest {
    return { projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "" };
  },

  toJSON(message: GetIntentsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetIntentsRequest>, I>>(base?: I): GetIntentsRequest {
    return GetIntentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetIntentsRequest>, I>>(object: I): GetIntentsRequest {
    const message = createBaseGetIntentsRequest();
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseGetScoreLimitsRequest(): GetScoreLimitsRequest {
  return { projectId: "", testSentencesUpperLimit: [], testSentencesLowerLimit: [] };
}

export const GetScoreLimitsRequest: MessageFns<GetScoreLimitsRequest> = {
  encode(message: GetScoreLimitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    for (const v of message.testSentencesUpperLimit) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.testSentencesLowerLimit) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScoreLimitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoreLimitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testSentencesUpperLimit.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testSentencesLowerLimit.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoreLimitsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testSentencesUpperLimit: globalThis.Array.isArray(object?.testSentencesUpperLimit)
        ? object.testSentencesUpperLimit.map((e: any) => globalThis.String(e))
        : [],
      testSentencesLowerLimit: globalThis.Array.isArray(object?.testSentencesLowerLimit)
        ? object.testSentencesLowerLimit.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetScoreLimitsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testSentencesUpperLimit?.length) {
      obj.testSentencesUpperLimit = message.testSentencesUpperLimit;
    }
    if (message.testSentencesLowerLimit?.length) {
      obj.testSentencesLowerLimit = message.testSentencesLowerLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoreLimitsRequest>, I>>(base?: I): GetScoreLimitsRequest {
    return GetScoreLimitsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoreLimitsRequest>, I>>(object: I): GetScoreLimitsRequest {
    const message = createBaseGetScoreLimitsRequest();
    message.projectId = object.projectId ?? "";
    message.testSentencesUpperLimit = object.testSentencesUpperLimit?.map((e) => e) || [];
    message.testSentencesLowerLimit = object.testSentencesLowerLimit?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetScoreLimitsResponse(): GetScoreLimitsResponse {
  return { minThreshold: 0, maxThreshold: 0 };
}

export const GetScoreLimitsResponse: MessageFns<GetScoreLimitsResponse> = {
  encode(message: GetScoreLimitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minThreshold !== 0) {
      writer.uint32(13).float(message.minThreshold);
    }
    if (message.maxThreshold !== 0) {
      writer.uint32(21).float(message.maxThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScoreLimitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoreLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.minThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxThreshold = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoreLimitsResponse {
    return {
      minThreshold: isSet(object.minThreshold) ? globalThis.Number(object.minThreshold) : 0,
      maxThreshold: isSet(object.maxThreshold) ? globalThis.Number(object.maxThreshold) : 0,
    };
  },

  toJSON(message: GetScoreLimitsResponse): unknown {
    const obj: any = {};
    if (message.minThreshold !== 0) {
      obj.minThreshold = message.minThreshold;
    }
    if (message.maxThreshold !== 0) {
      obj.maxThreshold = message.maxThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoreLimitsResponse>, I>>(base?: I): GetScoreLimitsResponse {
    return GetScoreLimitsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoreLimitsResponse>, I>>(object: I): GetScoreLimitsResponse {
    const message = createBaseGetScoreLimitsResponse();
    message.minThreshold = object.minThreshold ?? 0;
    message.maxThreshold = object.maxThreshold ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
