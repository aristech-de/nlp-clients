// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: intents.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "aristech.nlp";

/** Copyright Aristech GmbH */

export interface Intent {
  /** ID of the intent */
  id: string;
  /** The project ID of the intent */
  projectId: string;
  /** The default locale for the intent's inputs and outputs */
  locale: string;
  /** Topic of the intent */
  topic: string;
  /** Inputs for the intent */
  inputs: IntentInput[];
  /** Possible chat outputs for the intent */
  outputChat: string[];
  /** Possible voice outputs for the intent */
  outputVoice: string[];
  /** Possible email outputs for the intent */
  outputEmail: string[];
  /** relation to other intents */
  relatedTo: Relation[];
  /** If the intent is a draft */
  published: boolean;
  /** Type of the intents inputs */
  type: Intent_InputType;
  excludeOutputFromSearch: boolean;
  /** List of keywords to force finding this intent */
  keywords: Keyword[];
  creatorId: string;
}

export enum Intent_InputType {
  CHAT = 0,
  MAIL = 1,
  VOICE = 2,
  UNRECOGNIZED = -1,
}

export function intent_InputTypeFromJSON(object: any): Intent_InputType {
  switch (object) {
    case 0:
    case "CHAT":
      return Intent_InputType.CHAT;
    case 1:
    case "MAIL":
      return Intent_InputType.MAIL;
    case 2:
    case "VOICE":
      return Intent_InputType.VOICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Intent_InputType.UNRECOGNIZED;
  }
}

export function intent_InputTypeToJSON(object: Intent_InputType): string {
  switch (object) {
    case Intent_InputType.CHAT:
      return "CHAT";
    case Intent_InputType.MAIL:
      return "MAIL";
    case Intent_InputType.VOICE:
      return "VOICE";
    case Intent_InputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * a type defining an input and its mapping to a uuid. if the uuid is set, the input gets edited
 * to the new input, if no id is set or the uuid does not exist, a new input is added to the
 * intent.
 */
export interface IntentInput {
  uuid: string;
  input: string;
}

export interface Relation {
  /** list of ids of  parent intents */
  parents: string[];
  /** list of ids of  child intents */
  children: string[];
  /** list of ids of same level intents */
  peers: string[];
}

export interface Keyword {
  /** a keyword for an intent */
  keyword: string;
  /** the priority for the keyword */
  priority: number;
}

/**
 * Adds or updates content to the vector database
 * if id of the intent is not set, a new intent is created for the project
 * if an id is set: first check if that id already exists and update it
 * if the id doesn't exist: create the intent with the given id.
 */
export interface UpdateContentRequest {
  intents: Intent[];
}

/** Response for add content */
export interface UpdateContentResponse {
  /** Status of the update */
  intentIds: string[];
}

/** Removes content from the vector database */
export interface RemoveContentRequest {
  /** ID of the Document to be removed */
  id: string[];
  /**  */
  projectId: string;
}

/** Response for remove content */
export interface RemoveContentResponse {
}

/** Request for content */
export interface GetContentRequest {
  /** Prompt for the content to be retrieved */
  prompt: string;
  /** Meta data for the content to be retrieved */
  projectId: string;
  /** The number of results to be returned */
  numResults: number;
  /** The threshold for the results to be returned */
  threshold: number;
  /** Content Filters */
  filters: ContentFilter[];
  /** Chat id for context */
  chatId: string;
}

/** Response for content */
export interface GetContentResponse {
  /** List of intents */
  items: ContentResponseItem[];
  /** The Chat ID that was sent to the server with the get content request */
  chatId: string;
}

export interface ContentFilter {
  /** The field to be filtered */
  field: string;
  /** The value to be filtered */
  value: string;
  /** Operator */
  operator: string;
  /** The label to be used for filtering */
  label: string[];
}

/** Response item for content */
export interface ContentResponseItem {
  /** Id of the intent's input that represents this match */
  id: string;
  /** Score of the content */
  score: number;
  /** The actual intent */
  intent:
    | Intent
    | undefined;
  /** fallbackmessage, gets set, when no intent was found in the search */
  fallbackMessage: string;
}

export interface GetIntentsRequest {
  projectId: string;
}

export interface GetIntentsResponse {
  intent: Intent[];
}

export interface GetScoreLimitsRequest {
  /** ID of the project to get the score Limits from */
  projectId: string;
  /** List of sentences to test for the upper limit */
  testSentencesUpperLimit: string[];
  /** List of sentences to test for the lower limit */
  testSentencesLowerLimit: string[];
}

export interface GetScoreLimitsResponse {
  /** The minimum threshold determined by random sentences */
  minThreshold: number;
  /**
   * The max threshold determined by using original input sentences for the
   * intents
   */
  maxThreshold: number;
}

function createBaseIntent(): Intent {
  return {
    id: "",
    projectId: "",
    locale: "",
    topic: "",
    inputs: [],
    outputChat: [],
    outputVoice: [],
    outputEmail: [],
    relatedTo: [],
    published: false,
    type: 0,
    excludeOutputFromSearch: false,
    keywords: [],
    creatorId: "",
  };
}

export const Intent: MessageFns<Intent> = {
  encode(message: Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.locale !== "") {
      writer.uint32(26).string(message.locale);
    }
    if (message.topic !== "") {
      writer.uint32(34).string(message.topic);
    }
    for (const v of message.inputs) {
      IntentInput.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.outputChat) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.outputVoice) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.outputEmail) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.relatedTo) {
      Relation.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.published !== false) {
      writer.uint32(80).bool(message.published);
    }
    if (message.type !== 0) {
      writer.uint32(88).int32(message.type);
    }
    if (message.excludeOutputFromSearch !== false) {
      writer.uint32(96).bool(message.excludeOutputFromSearch);
    }
    for (const v of message.keywords) {
      Keyword.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.creatorId !== "") {
      writer.uint32(114).string(message.creatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputs.push(IntentInput.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputChat.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputVoice.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outputEmail.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.relatedTo.push(Relation.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.published = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.excludeOutputFromSearch = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.keywords.push(Keyword.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      locale: isSet(object.locale) ? globalThis.String(object.locale) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => IntentInput.fromJSON(e)) : [],
      outputChat: globalThis.Array.isArray(object?.outputChat)
        ? object.outputChat.map((e: any) => globalThis.String(e))
        : [],
      outputVoice: globalThis.Array.isArray(object?.outputVoice)
        ? object.outputVoice.map((e: any) => globalThis.String(e))
        : [],
      outputEmail: globalThis.Array.isArray(object?.outputEmail)
        ? object.outputEmail.map((e: any) => globalThis.String(e))
        : [],
      relatedTo: globalThis.Array.isArray(object?.relatedTo)
        ? object.relatedTo.map((e: any) => Relation.fromJSON(e))
        : [],
      published: isSet(object.published) ? globalThis.Boolean(object.published) : false,
      type: isSet(object.type) ? intent_InputTypeFromJSON(object.type) : 0,
      excludeOutputFromSearch: isSet(object.excludeOutputFromSearch)
        ? globalThis.Boolean(object.excludeOutputFromSearch)
        : false,
      keywords: globalThis.Array.isArray(object?.keywords)
        ? object.keywords.map((e: any) => Keyword.fromJSON(e))
        : [],
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
    };
  },

  toJSON(message: Intent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.locale !== "") {
      obj.locale = message.locale;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => IntentInput.toJSON(e));
    }
    if (message.outputChat?.length) {
      obj.outputChat = message.outputChat;
    }
    if (message.outputVoice?.length) {
      obj.outputVoice = message.outputVoice;
    }
    if (message.outputEmail?.length) {
      obj.outputEmail = message.outputEmail;
    }
    if (message.relatedTo?.length) {
      obj.relatedTo = message.relatedTo.map((e) => Relation.toJSON(e));
    }
    if (message.published !== false) {
      obj.published = message.published;
    }
    if (message.type !== 0) {
      obj.type = intent_InputTypeToJSON(message.type);
    }
    if (message.excludeOutputFromSearch !== false) {
      obj.excludeOutputFromSearch = message.excludeOutputFromSearch;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords.map((e) => Keyword.toJSON(e));
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Intent>, I>>(base?: I): Intent {
    return Intent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Intent>, I>>(object: I): Intent {
    const message = createBaseIntent();
    message.id = object.id ?? "";
    message.projectId = object.projectId ?? "";
    message.locale = object.locale ?? "";
    message.topic = object.topic ?? "";
    message.inputs = object.inputs?.map((e) => IntentInput.fromPartial(e)) || [];
    message.outputChat = object.outputChat?.map((e) => e) || [];
    message.outputVoice = object.outputVoice?.map((e) => e) || [];
    message.outputEmail = object.outputEmail?.map((e) => e) || [];
    message.relatedTo = object.relatedTo?.map((e) => Relation.fromPartial(e)) || [];
    message.published = object.published ?? false;
    message.type = object.type ?? 0;
    message.excludeOutputFromSearch = object.excludeOutputFromSearch ?? false;
    message.keywords = object.keywords?.map((e) => Keyword.fromPartial(e)) || [];
    message.creatorId = object.creatorId ?? "";
    return message;
  },
};

function createBaseIntentInput(): IntentInput {
  return { uuid: "", input: "" };
}

export const IntentInput: MessageFns<IntentInput> = {
  encode(message: IntentInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentInput {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
    };
  },

  toJSON(message: IntentInput): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntentInput>, I>>(base?: I): IntentInput {
    return IntentInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntentInput>, I>>(object: I): IntentInput {
    const message = createBaseIntentInput();
    message.uuid = object.uuid ?? "";
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseRelation(): Relation {
  return { parents: [], children: [], peers: [] };
}

export const Relation: MessageFns<Relation> = {
  encode(message: Relation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parents) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.children) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.peers) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Relation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parents.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.peers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Relation {
    return {
      parents: globalThis.Array.isArray(object?.parents) ? object.parents.map((e: any) => globalThis.String(e)) : [],
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => globalThis.String(e)) : [],
      peers: globalThis.Array.isArray(object?.peers) ? object.peers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Relation): unknown {
    const obj: any = {};
    if (message.parents?.length) {
      obj.parents = message.parents;
    }
    if (message.children?.length) {
      obj.children = message.children;
    }
    if (message.peers?.length) {
      obj.peers = message.peers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Relation>, I>>(base?: I): Relation {
    return Relation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Relation>, I>>(object: I): Relation {
    const message = createBaseRelation();
    message.parents = object.parents?.map((e) => e) || [];
    message.children = object.children?.map((e) => e) || [];
    message.peers = object.peers?.map((e) => e) || [];
    return message;
  },
};

function createBaseKeyword(): Keyword {
  return { keyword: "", priority: 0 };
}

export const Keyword: MessageFns<Keyword> = {
  encode(message: Keyword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyword !== "") {
      writer.uint32(10).string(message.keyword);
    }
    if (message.priority !== 0) {
      writer.uint32(16).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Keyword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Keyword {
    return {
      keyword: isSet(object.keyword) ? globalThis.String(object.keyword) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: Keyword): unknown {
    const obj: any = {};
    if (message.keyword !== "") {
      obj.keyword = message.keyword;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Keyword>, I>>(base?: I): Keyword {
    return Keyword.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Keyword>, I>>(object: I): Keyword {
    const message = createBaseKeyword();
    message.keyword = object.keyword ?? "";
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseUpdateContentRequest(): UpdateContentRequest {
  return { intents: [] };
}

export const UpdateContentRequest: MessageFns<UpdateContentRequest> = {
  encode(message: UpdateContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intents) {
      Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intents.push(Intent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContentRequest {
    return {
      intents: globalThis.Array.isArray(object?.intents) ? object.intents.map((e: any) => Intent.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateContentRequest): unknown {
    const obj: any = {};
    if (message.intents?.length) {
      obj.intents = message.intents.map((e) => Intent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(base?: I): UpdateContentRequest {
    return UpdateContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(object: I): UpdateContentRequest {
    const message = createBaseUpdateContentRequest();
    message.intents = object.intents?.map((e) => Intent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateContentResponse(): UpdateContentResponse {
  return { intentIds: [] };
}

export const UpdateContentResponse: MessageFns<UpdateContentResponse> = {
  encode(message: UpdateContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intentIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intentIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContentResponse {
    return {
      intentIds: globalThis.Array.isArray(object?.intentIds)
        ? object.intentIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateContentResponse): unknown {
    const obj: any = {};
    if (message.intentIds?.length) {
      obj.intentIds = message.intentIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContentResponse>, I>>(base?: I): UpdateContentResponse {
    return UpdateContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContentResponse>, I>>(object: I): UpdateContentResponse {
    const message = createBaseUpdateContentResponse();
    message.intentIds = object.intentIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveContentRequest(): RemoveContentRequest {
  return { id: [], projectId: "" };
}

export const RemoveContentRequest: MessageFns<RemoveContentRequest> = {
  encode(message: RemoveContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.id) {
      writer.uint32(10).string(v!);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveContentRequest {
    return {
      id: globalThis.Array.isArray(object?.id) ? object.id.map((e: any) => globalThis.String(e)) : [],
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
    };
  },

  toJSON(message: RemoveContentRequest): unknown {
    const obj: any = {};
    if (message.id?.length) {
      obj.id = message.id;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveContentRequest>, I>>(base?: I): RemoveContentRequest {
    return RemoveContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveContentRequest>, I>>(object: I): RemoveContentRequest {
    const message = createBaseRemoveContentRequest();
    message.id = object.id?.map((e) => e) || [];
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseRemoveContentResponse(): RemoveContentResponse {
  return {};
}

export const RemoveContentResponse: MessageFns<RemoveContentResponse> = {
  encode(_: RemoveContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveContentResponse {
    return {};
  },

  toJSON(_: RemoveContentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveContentResponse>, I>>(base?: I): RemoveContentResponse {
    return RemoveContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveContentResponse>, I>>(_: I): RemoveContentResponse {
    const message = createBaseRemoveContentResponse();
    return message;
  },
};

function createBaseGetContentRequest(): GetContentRequest {
  return { prompt: "", projectId: "", numResults: 0, threshold: 0, filters: [], chatId: "" };
}

export const GetContentRequest: MessageFns<GetContentRequest> = {
  encode(message: GetContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    if (message.projectId !== "") {
      writer.uint32(18).string(message.projectId);
    }
    if (message.numResults !== 0) {
      writer.uint32(24).int32(message.numResults);
    }
    if (message.threshold !== 0) {
      writer.uint32(37).float(message.threshold);
    }
    for (const v of message.filters) {
      ContentFilter.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.chatId !== "") {
      writer.uint32(58).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numResults = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.threshold = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters.push(ContentFilter.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContentRequest {
    return {
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      numResults: isSet(object.numResults) ? globalThis.Number(object.numResults) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => ContentFilter.fromJSON(e))
        : [],
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: GetContentRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.numResults !== 0) {
      obj.numResults = Math.round(message.numResults);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => ContentFilter.toJSON(e));
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContentRequest>, I>>(base?: I): GetContentRequest {
    return GetContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContentRequest>, I>>(object: I): GetContentRequest {
    const message = createBaseGetContentRequest();
    message.prompt = object.prompt ?? "";
    message.projectId = object.projectId ?? "";
    message.numResults = object.numResults ?? 0;
    message.threshold = object.threshold ?? 0;
    message.filters = object.filters?.map((e) => ContentFilter.fromPartial(e)) || [];
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseGetContentResponse(): GetContentResponse {
  return { items: [], chatId: "" };
}

export const GetContentResponse: MessageFns<GetContentResponse> = {
  encode(message: GetContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ContentResponseItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ContentResponseItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContentResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ContentResponseItem.fromJSON(e))
        : [],
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: GetContentResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ContentResponseItem.toJSON(e));
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContentResponse>, I>>(base?: I): GetContentResponse {
    return GetContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContentResponse>, I>>(object: I): GetContentResponse {
    const message = createBaseGetContentResponse();
    message.items = object.items?.map((e) => ContentResponseItem.fromPartial(e)) || [];
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseContentFilter(): ContentFilter {
  return { field: "", value: "", operator: "", label: [] };
}

export const ContentFilter: MessageFns<ContentFilter> = {
  encode(message: ContentFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    for (const v of message.label) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentFilter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
      label: globalThis.Array.isArray(object?.label) ? object.label.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ContentFilter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    if (message.label?.length) {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentFilter>, I>>(base?: I): ContentFilter {
    return ContentFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentFilter>, I>>(object: I): ContentFilter {
    const message = createBaseContentFilter();
    message.field = object.field ?? "";
    message.value = object.value ?? "";
    message.operator = object.operator ?? "";
    message.label = object.label?.map((e) => e) || [];
    return message;
  },
};

function createBaseContentResponseItem(): ContentResponseItem {
  return { id: "", score: 0, intent: undefined, fallbackMessage: "" };
}

export const ContentResponseItem: MessageFns<ContentResponseItem> = {
  encode(message: ContentResponseItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.intent !== undefined) {
      Intent.encode(message.intent, writer.uint32(26).fork()).join();
    }
    if (message.fallbackMessage !== "") {
      writer.uint32(34).string(message.fallbackMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentResponseItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentResponseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intent = Intent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fallbackMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentResponseItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      intent: isSet(object.intent) ? Intent.fromJSON(object.intent) : undefined,
      fallbackMessage: isSet(object.fallbackMessage) ? globalThis.String(object.fallbackMessage) : "",
    };
  },

  toJSON(message: ContentResponseItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.intent !== undefined) {
      obj.intent = Intent.toJSON(message.intent);
    }
    if (message.fallbackMessage !== "") {
      obj.fallbackMessage = message.fallbackMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentResponseItem>, I>>(base?: I): ContentResponseItem {
    return ContentResponseItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentResponseItem>, I>>(object: I): ContentResponseItem {
    const message = createBaseContentResponseItem();
    message.id = object.id ?? "";
    message.score = object.score ?? 0;
    message.intent = (object.intent !== undefined && object.intent !== null)
      ? Intent.fromPartial(object.intent)
      : undefined;
    message.fallbackMessage = object.fallbackMessage ?? "";
    return message;
  },
};

function createBaseGetIntentsRequest(): GetIntentsRequest {
  return { projectId: "" };
}

export const GetIntentsRequest: MessageFns<GetIntentsRequest> = {
  encode(message: GetIntentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIntentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIntentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIntentsRequest {
    return { projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "" };
  },

  toJSON(message: GetIntentsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetIntentsRequest>, I>>(base?: I): GetIntentsRequest {
    return GetIntentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetIntentsRequest>, I>>(object: I): GetIntentsRequest {
    const message = createBaseGetIntentsRequest();
    message.projectId = object.projectId ?? "";
    return message;
  },
};

function createBaseGetIntentsResponse(): GetIntentsResponse {
  return { intent: [] };
}

export const GetIntentsResponse: MessageFns<GetIntentsResponse> = {
  encode(message: GetIntentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.intent) {
      Intent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIntentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIntentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.intent.push(Intent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIntentsResponse {
    return {
      intent: globalThis.Array.isArray(object?.intent) ? object.intent.map((e: any) => Intent.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetIntentsResponse): unknown {
    const obj: any = {};
    if (message.intent?.length) {
      obj.intent = message.intent.map((e) => Intent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetIntentsResponse>, I>>(base?: I): GetIntentsResponse {
    return GetIntentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetIntentsResponse>, I>>(object: I): GetIntentsResponse {
    const message = createBaseGetIntentsResponse();
    message.intent = object.intent?.map((e) => Intent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetScoreLimitsRequest(): GetScoreLimitsRequest {
  return { projectId: "", testSentencesUpperLimit: [], testSentencesLowerLimit: [] };
}

export const GetScoreLimitsRequest: MessageFns<GetScoreLimitsRequest> = {
  encode(message: GetScoreLimitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    for (const v of message.testSentencesUpperLimit) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.testSentencesLowerLimit) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScoreLimitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoreLimitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testSentencesUpperLimit.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.testSentencesLowerLimit.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoreLimitsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      testSentencesUpperLimit: globalThis.Array.isArray(object?.testSentencesUpperLimit)
        ? object.testSentencesUpperLimit.map((e: any) => globalThis.String(e))
        : [],
      testSentencesLowerLimit: globalThis.Array.isArray(object?.testSentencesLowerLimit)
        ? object.testSentencesLowerLimit.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetScoreLimitsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.testSentencesUpperLimit?.length) {
      obj.testSentencesUpperLimit = message.testSentencesUpperLimit;
    }
    if (message.testSentencesLowerLimit?.length) {
      obj.testSentencesLowerLimit = message.testSentencesLowerLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoreLimitsRequest>, I>>(base?: I): GetScoreLimitsRequest {
    return GetScoreLimitsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoreLimitsRequest>, I>>(object: I): GetScoreLimitsRequest {
    const message = createBaseGetScoreLimitsRequest();
    message.projectId = object.projectId ?? "";
    message.testSentencesUpperLimit = object.testSentencesUpperLimit?.map((e) => e) || [];
    message.testSentencesLowerLimit = object.testSentencesLowerLimit?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetScoreLimitsResponse(): GetScoreLimitsResponse {
  return { minThreshold: 0, maxThreshold: 0 };
}

export const GetScoreLimitsResponse: MessageFns<GetScoreLimitsResponse> = {
  encode(message: GetScoreLimitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minThreshold !== 0) {
      writer.uint32(13).float(message.minThreshold);
    }
    if (message.maxThreshold !== 0) {
      writer.uint32(21).float(message.maxThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScoreLimitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoreLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.minThreshold = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.maxThreshold = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoreLimitsResponse {
    return {
      minThreshold: isSet(object.minThreshold) ? globalThis.Number(object.minThreshold) : 0,
      maxThreshold: isSet(object.maxThreshold) ? globalThis.Number(object.maxThreshold) : 0,
    };
  },

  toJSON(message: GetScoreLimitsResponse): unknown {
    const obj: any = {};
    if (message.minThreshold !== 0) {
      obj.minThreshold = message.minThreshold;
    }
    if (message.maxThreshold !== 0) {
      obj.maxThreshold = message.maxThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoreLimitsResponse>, I>>(base?: I): GetScoreLimitsResponse {
    return GetScoreLimitsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoreLimitsResponse>, I>>(object: I): GetScoreLimitsResponse {
    const message = createBaseGetScoreLimitsResponse();
    message.minThreshold = object.minThreshold ?? 0;
    message.maxThreshold = object.maxThreshold ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
